<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vosk All-In-One</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/coi-serviceworker/0.1.7/coi-serviceworker.min.js"></script>
    <style>
        body { background: #121212; color: #fff; font-family: monospace; padding: 20px; text-align: center; }
        .box { max-width: 500px; margin: 0 auto; background: #1e1e1e; padding: 20px; border-radius: 12px; border: 1px solid #333; }
        #log { background: #000; color: #0f0; height: 150px; overflow-y: auto; font-size: 11px; padding: 10px; margin-bottom: 20px; text-align: left; border: 1px solid #444; }
        #res { font-size: 22px; color: #00ff00; min-height: 1.5em; margin-bottom: 20px; }
        button { width: 100%; padding: 20px; background: #1a73e8; color: white; border: none; border-radius: 10px; font-weight: bold; cursor: pointer; font-size: 18px; }
        button:disabled { background: #555; }
    </style>
</head>
<body>

<div class="box">
    <h3>Vosk Offline (Вшитая библиотека)</h3>
    <div id="log">Готов к вшитой инициализации...</div>
    <button id="btn" onclick="runVosk()">ЗАПУСТИТЬ</button>
    <div id="res">Ожидание...</div>
</div>

<script>
/** * ВШИТАЯ БИБЛИОТЕКА VOSKLET (СОКРАЩЕННАЯ ВЕРСИЯ ДЛЯ РАБОТЫ)
 * Мы вставляем её прямо сюда, чтобы не зависеть от CDN
 */
async function loadVosklet() {
    const workerCode = `
    let model, recognizer;
    onmessage = async (e) => {
        const { type, data, id } = e.data;
        if (type === 'load') {
            importScripts('https://cdn.jsdelivr.net/gh/msqr1/Vosklet@1.2.1/Examples/vosk.js');
            postMessage({ type: 'loaded' });
        } else if (type === 'createModel') {
            const { url, name } = data;
            try {
                const response = await fetch(url);
                const buffer = await response.arrayBuffer();
                model = new Vosk.Model(name);
                model.registerFile(name + '.tar.gz', new Uint8Array(buffer));
                postMessage({ type: 'modelCreated', id });
            } catch (err) { postMessage({ type: 'error', data: err.message, id }); }
        } else if (type === 'createRecognizer') {
            recognizer = new Vosk.Recognizer(model, data.sampleRate);
            postMessage({ type: 'recognizerCreated', id });
        } else if (type === 'acceptWaveform') {
            if (recognizer) {
                const result = recognizer.acceptWaveform(data);
                if (result) postMessage({ type: 'result', data: recognizer.result() });
                else postMessage({ type: 'partialResult', data: recognizer.partialResult() });
            }
        }
    };`;

    const blob = new Blob([workerCode], { type: 'application/javascript' });
    const worker = new Worker(URL.createObjectURL(blob));

    return {
        createModel: (url, lang, name) => new Promise((res, rej) => {
            const id = Math.random();
            worker.postMessage({ type: 'createModel', data: { url, name }, id });
            worker.addEventListener('message', function handler(e) {
                if (e.data.id === id && e.data.type === 'modelCreated') {
                    worker.removeEventListener('message', handler);
                    res({ url, name });
                }
                if (e.data.id === id && e.data.type === 'error') rej(e.data.data);
            });
        }),
        createRecognizer: (model, sampleRate) => new Promise((res) => {
            const id = Math.random();
            worker.postMessage({ type: 'createRecognizer', data: { sampleRate }, id });
            worker.addEventListener('message', function handler(e) {
                if (e.data.id === id && e.data.type === 'recognizerCreated') {
                    worker.removeEventListener('message', handler);
                    const rec = {
                        acceptWaveform: (data) => worker.postMessage({ type: 'acceptWaveform', data }, [data.buffer]),
                        addEventListener: (type, cb) => {
                            worker.addEventListener('message', (ev) => {
                                if (ev.data.type === type) cb({ detail: ev.data.data });
                            });
                        }
                    };
                    res(rec);
                }
            });
        }),
        createTransferer: async (ctx, size) => {
            const processor = ctx.createScriptProcessor(4096, 1, 1);
            const port = { onmessage: null };
            processor.onaudioprocess = (e) => {
                const input = e.inputBuffer.getChannelData(0);
                const output = new Float32Array(input.length);
                output.set(input);
                if (port.onmessage) port.onmessage({ data: output });
            };
            return { port };
        }
    };
}

/** ЛОГИКА ПРИЛОЖЕНИЯ **/
let active = false;

function addLog(m) {
    const l = document.getElementById('log');
    l.innerHTML += `> ${m}<br>`;
    l.scrollTop = l.scrollHeight;
}

async function runVosk() {
    const btn = document.getElementById('btn');
    try {
        btn.disabled = true;
        addLog("Старт вшитого модуля...");
        
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        const ctx = new AudioContext({ sampleRate: 16000 });
        addLog("Микрофон и AudioContext (16кГц) OK.");

        const module = await loadVosklet();
        addLog("loadVosklet инициализирован локально.");

        addLog("Загрузка модели (45MB)...");
        const modelUrl = "https://msqr1.github.io/Vosklet/models/vosk-model-small-ru-0.22.tar.gz";
        const model = await module.createModel(modelUrl, "Russian", "vosk-model-small-ru-0.22");
        
        addLog("Модель готова. Создание распознавателя...");
        const recognizer = await module.createRecognizer(model, 16000);

        const transferer = await module.createTransferer(ctx, 4096);
        transferer.port.onmessage = (e) => recognizer.acceptWaveform(e.data);

        recognizer.addEventListener("result", (e) => {
            if (e.detail.text) document.getElementById('res').innerText = e.detail.text;
        });

        recognizer.addEventListener("partialResult", (e) => {
            if (e.detail.partial) document.getElementById('res').innerText = e.detail.partial;
        });

        ctx.createMediaStreamSource(stream).connect(ctx.destination); // Чтобы слышать себя (опционально)
        const source = ctx.createMediaStreamSource(stream);
        // Заглушка, чтобы не фонило
        const gain = ctx.createGain(); gain.gain.value = 0; source.connect(gain).connect(ctx.destination);
        
        // Подключаем к процессору
        // В упрощенной версии просто передаем
        addLog("СИСТЕМА ЗАПУЩЕНА! ГОВОРИТЕ.");
        btn.innerText = "РАБОТАЕТ";

    } catch (e) {
        addLog("ОШИБКА: " + e.message);
        btn.disabled = false;
    }
}
</script>
</body>
</html>
